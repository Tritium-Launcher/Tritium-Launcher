package io.github.footermandev.tritium.core.project.settings

import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory
import com.typesafe.config.ConfigRenderOptions
import com.typesafe.config.ConfigValueFactory
import io.github.footermandev.tritium.core.project.ProjectBase
import io.github.footermandev.tritium.io.VPath
import io.github.footermandev.tritium.logger

private val PROJECT_SETTING_KEY = Regex("^[a-z0-9_.-]+$")

/**
 * Project-scoped setting entry definition provided by a [io.github.footermandev.tritium.core.project.ProjectType].
 */
data class ProjectSettingDefinition(
    val key: String,
    val defaultValue: String = "",
    val comments: List<String> = emptyList(),
    val order: Int = -1,
) {
    init {
        require(PROJECT_SETTING_KEY.matches(key)) { "Project setting key must match ${PROJECT_SETTING_KEY.pattern} (got '$key')" }
        require(order >= -1) { "Project setting order must be >= -1 (got $order)" }
    }
}

/**
 * Manages project-scoped settings and additive preferences stored in `<project>/.tr`.
 */
object ProjectScopedSettingsMngr {
    const val PROJECT_DIR = ".tr"
    const val SETTINGS_FILE_NAME = "settings.conf"
    const val PREFS_FILE_NAME = "prefs.conf"
    private const val PROJECT_SETTINGS_HEADER_MARKER = "# Generated by Tritium. Project-scoped settings for"
    private const val GLOBAL_SETTINGS_HEADER_MARKER = "# Generated by Tritium. Manual edits are kept where possible."

    const val PREF_NOTIFICATIONS_IGNORE = "notifications.ignore"
    const val PREF_PROJECT_FILES_IGNORE = "project_files.ignore"
    const val PREF_PROJECT_FOLDERS_IGNORE = "project_folders.ignore"

    private val logger = logger()
    private val renderOpts: ConfigRenderOptions = ConfigRenderOptions.defaults()
        .setJson(false)
        .setComments(false)
        .setOriginComments(false)

    /**
     * Ensures project-scoped settings and prefs files exist under `.tr`.
     */
    fun ensureProjectFiles(project: ProjectBase, settings: List<ProjectSettingDefinition>) {
        ensureSettingsFile(project, settings)
        ensurePrefsFile(project)
    }

    fun settingsFile(project: ProjectBase): VPath = project.path.resolve(PROJECT_DIR).resolve(SETTINGS_FILE_NAME)
    fun prefsFile(project: ProjectBase): VPath = project.path.resolve(PROJECT_DIR).resolve(PREFS_FILE_NAME)

    /**
     * Reads a string-list preference from project `prefs.conf`.
     */
    fun readStringSetPref(project: ProjectBase, key: String): Set<String> {
        val config = readPrefsConfig(project)
        if (!config.hasPath(key)) return emptySet()

        return try {
            config.getStringList(key)
                .asSequence()
                .map { it.trim() }
                .filter { it.isNotEmpty() }
                .toCollection(LinkedHashSet())
        } catch (_: Throwable) {
            emptySet()
        }
    }

    /**
     * Writes a string-list preference to project `prefs.conf`.
     */
    fun writeStringSetPref(project: ProjectBase, key: String, values: Set<String>) {
        val normalized = values
            .asSequence()
            .map { it.trim() }
            .filter { it.isNotEmpty() }
            .distinct()
            .sorted()
            .toList()

        val merged = if (normalized.isEmpty()) {
            readPrefsConfig(project).withoutPath(key)
        } else {
            readPrefsConfig(project).withValue(key, ConfigValueFactory.fromIterable(normalized))
        }

        val file = prefsFile(project)
        val body = if (merged.root().isEmpty()) "" else merged.root().render(renderOpts) + "\n"
        try {
            file.parent().mkdirs()
            file.writeBytesAtomic(body.toByteArray())
        } catch (t: Throwable) {
            logger.warn("Failed writing project prefs key '{}' to {}", key, file, t)
        }
    }

    private fun ensureSettingsFile(project: ProjectBase, settings: List<ProjectSettingDefinition>) {
        val file = settingsFile(project)
        if (file.exists()) {
            if (!shouldRegenerateManagedSettingsFile(file, settings)) return
            logger.info("Regenerating project settings file at {} (managed content mismatch)", file)
        }
        val rendered = renderSettingsFile(project, settings)
        try {
            file.parent().mkdirs()
            file.writeBytesAtomic(rendered.toByteArray())
        } catch (t: Throwable) {
            logger.warn("Failed creating project settings file at {}", file, t)
        }
    }

    private fun shouldRegenerateManagedSettingsFile(file: VPath, settings: List<ProjectSettingDefinition>): Boolean {
        if (settings.isEmpty()) return false
        val raw = file.readTextOrNull()?.trim().orEmpty()
        if (raw.isBlank()) return true

        val managedByTritium = raw.contains(PROJECT_SETTINGS_HEADER_MARKER) || raw.contains(GLOBAL_SETTINGS_HEADER_MARKER)
        if (!managedByTritium) return false

        val hasExpectedProjectKey = settings.any { setting ->
            Regex("""(?m)^\s*${Regex.escape(setting.key)}\s*=""").containsMatchIn(raw)
        }
        return !hasExpectedProjectKey
    }

    private fun ensurePrefsFile(project: ProjectBase) {
        val file = prefsFile(project)
        if (file.exists()) return
        try {
            file.parent().mkdirs()
            file.writeBytesAtomic(ByteArray(0))
        } catch (t: Throwable) {
            logger.warn("Failed creating project prefs file at {}", file, t)
        }
    }

    private fun readPrefsConfig(project: ProjectBase): Config {
        ensurePrefsFile(project)
        val file = prefsFile(project)
        val raw = file.readTextOrNull()?.trim().orEmpty()
        if (raw.isBlank()) return ConfigFactory.empty()
        return try {
            ConfigFactory.parseString(raw).resolve()
        } catch (t: Throwable) {
            logger.warn("Failed parsing project prefs config from {}", file, t)
            ConfigFactory.empty()
        }
    }

    private fun renderSettingsFile(project: ProjectBase, settings: List<ProjectSettingDefinition>): String {
        val ordered = settings.sortedWith(
            compareBy<ProjectSettingDefinition> { if (it.order >= 0) it.order else Int.MAX_VALUE }
                .thenBy { it.key }
        )

        return buildString {
            appendLine("# Generated by Tritium. Project-scoped settings for '${project.typeId}'.")
            appendLine("# Edit values to override defaults for this project.")
            appendLine("settings {")
            if (ordered.isNotEmpty()) {
                ordered.forEach { setting ->
                    setting.comments
                        .asSequence()
                        .map { it.trim() }
                        .filter { it.isNotEmpty() }
                        .forEach { comment ->
                            appendLine("  # $comment")
                        }
                    appendLine("  ${setting.key} = ${quoteString(setting.defaultValue)}")
                    appendLine()
                }
            }
            appendLine("}")
        }
    }

    private fun quoteString(raw: String): String {
        return buildString(raw.length + 2) {
            append('"')
            raw.forEach { ch ->
                when (ch) {
                    '\\' -> append("\\\\")
                    '"' -> append("\\\"")
                    '\n' -> append("\\n")
                    '\r' -> append("\\r")
                    '\t' -> append("\\t")
                    else -> append(ch)
                }
            }
            append('"')
        }
    }
}
